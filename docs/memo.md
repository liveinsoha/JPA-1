## @DiscriminatorColumn은 Java에서 객체 지향 매핑(ORM)을 수행하는데 사용되는 어노테이션 중 하나로,
Hibernate와 같은 ORM 프레임워크에서 엔티티 클래스의 계층 구조를 매핑하는 데 사용됩니다. 특히, 상속 관계 매핑에서 사용됩니다.
해당 어노테이션은 하위 클래스들을 식별하기 위한 열을 데이터베이스 테이블에 추가하는 데 사용됩니다.
일반적으로 하위 클래스들은 부모 클래스를 상속받아 구현되며, 데이터베이스 테이블에 저장될 때 각각의 행은 자체의
특정 타입을 나타내는데, 이를 구분하기 위해 @DiscriminatorColumn이 사용됩니다.
@DiscriminatorColumn 어노테이션에는 name 속성이 있습니다. 여기서 "dtype"는 데이터베이스 테이블에
추가될 열의 이름을 지정합니다. "dtype"는 "Discriminator Type"의 약어로, 하위 클래스들을 식별하는 데 사용되는 열입니다.

## 엔터티 매니징 (Entity Management):
EntityManager는 JPA에서 엔터티의 생명주기를 관리하고 영속성 컨텍스트를 통해 엔터티 객체의 상태를 추적합니다. 영속성 컨텍스트는 엔터티와 데이터베이스 간의 매핑을 담당하며, 엔터티의 영속성 상태를 관리합니다.
영속성(Persistence): 영속성이란 엔터티 객체가 데이터베이스와 연결되어 있는 상태를 말합니다. 즉, 엔터티의 상태가 영속성 컨텍스트에 의해 추적되고 데이터베이스에 저장될 수 있게 되는 것을 의미합니다.
트랜잭션 범위 내에서의 관리: EntityManager를 사용하여 엔터티를 조회, 저장, 수정, 삭제할 때는 트랜잭션 범위 내에서 이루어져야 합니다. 이는 변경된 엔터티들이 데이터베이스에 일괄적으로 반영되거나 롤백될 수 있도록 보장합니다.
트랜잭션 관리:
EntityManager는 트랜잭션을 시작하고 커밋 또는 롤백하는 데 사용됩니다. 트랜잭션은 일련의 연산을 논리적으로 묶어서 원자적으로 실행하는 데 사용됩니다. 엔터티 매니징은 트랜잭션 내에서 이루어져야 하며, 트랜잭션을 통해 엔터티의 영속성 상태가 일관되게 유지됩니다.
트랜잭션의 커밋과 롤백: EntityManager를 통해 엔터티를 조작한 후, 트랜잭션을 커밋하면 변경사항이 데이터베이스에 반영되고, 롤백하면 변경사항이 취소되어 이전 상태로 돌아갑니다.
트랜잭션의 범위: 엔터티 매니징은 트랜잭션 내에서만 이루어져야 하며, 트랜잭션 범위 밖에서는 영속성 컨텍스트가 적용되지 않습니다.

## 도메인 개발 -> 서비스, 리포지토리 계층 개발 -> 테스트 작성하고 검증 -> 마지막에 웹 계층 적용


## em.persist(member)를 호출하는 시점에서 member 엔터티의 @Id 필드가 자동으로 생성되어 지정되어야 합니다.
JPA에서 엔터티가 데이터베이스에 저장될 때, 해당 엔터티의 @Id 필드가 자동으로 생성되는 방법은 크게 두 가지입니다:
자동 생성 전략 (Auto Generation Strategy):
일반적으로 @Id 필드에 대한 자동 생성 전략을 설정합니다. 대표적으로 사용되는 전략은 GenerationType.IDENTITY, GenerationType.SEQUENCE, GenerationType.TABLE, GenerationType.AUTO 등이 있습니다.
예를 들어, GenerationType.IDENTITY를 사용하면 데이터베이스의 자동 증가(Auto Increment) 기능을 활용하여 @Id 필드의 값을 자동으로 생성합니다.
기본 키 생성 전략 (Primary Key Generation Strategy):
데이터베이스에서 자동 생성된 키 값을 가져오는 방법으로, 데이터베이스에 따라 시퀀스, 테이블 등을 활용할 수 있습니다.

## 생성자 주입의 장점
불변성(Immutability) 및 불변 객체:
생성자 주입을 사용하면 한 번 생성된 객체는 불변하게 유지될 수 있습니다. 의존성이 객체 생성 시 주입되면, 
이후에 해당 객체는 내부 상태를 변경하지 않아도 됩니다. 이는 코드를 더 안정적으로 만들어주고, 예측 가능한 객체 상태를 제공합니다.
의존성 주입을 강제화(Forced Dependency):
생성자 주입은 객체 생성 시에 필요한 모든 의존성을 주입받아야 하기 때문에, 필수적인 의존성이 빠지지 않도록 강제할 수 있습니다. 
이는 객체가 필요한 의존성을 가지고 있는지를 보다 명확하게 확인할 수 있게 해줍니다.
의존성 추적과 가시성(Visibility):
생성자 주입을 사용하면 객체의 의존성이 외부에서 주입되므로, 코드를 읽는 사람이나 다른 개발자가 클래스의 의존성을 추적하기가 더 쉬워집니다. 
코드의 가시성이 높아져서 클래스가 어떤 의존성을 필요로 하는지 명확하게 보이게 됩니다.
테스트 용이성(Testability):
생성자 주입을 사용하면 의존성을 쉽게 목(mock) 객체로 대체할 수 있습니다. 테스트 코드에서 특정 의존성을 주입함으로써 특정 동작을 시뮬레이션하거나 테스트할 수 있습니다.
의존성의 변경 용이성:
생성자 주입을 사용하면 의존성이 변경될 경우에도 클래스 내부 변경이 최소화됩니다. 생성자의 파라미터만 수정하면 되기 때문에, 의존성의 변경에 따른 영향을 최소화할 수 있습니다.
Spring Framework와의 호환성:
Spring Framework에서는 생성자 주입을 선호하고 지원합니다. Spring의 @Autowired 어노테이션을 사용할 때 생성자 주입을 하면, 코드의 가독성이 향상되며 Spring 컨테이너의 의존성 주입 기능을 최대한 활용할 수 있습니다.

## @PersistenceContext 어노테이션은 JPA(Java Persistence API)에서 사용되며, 영속성 컨텍스트를 주입받기 위해 사용됩니다. 
이 어노테이션을 사용하면 엔터티 매니저(EntityManager)를 주입받아 JPA를 사용하는 클래스에서 데이터베이스와의 상호작용을 할 수 있습니다.
여기서 몇 가지 주요한 포인트를 설명하겠습니다:

엔터티 매니저 주입:
@PersistenceContext 어노테이션을 필드, 메서드, 또는 생성자에 적용하여 엔터티 매니저를 주입받을 수 있습니다.
주입된 엔터티 매니저를 사용하여 영속성 컨텍스트에서 엔터티의 조회, 저장, 수정, 삭제 등의 작업을 수행할 수 있습니다.
스프링에서의 활용:
@PersistenceContext는 주로 Java EE 환경에서 사용되었으나, 스프링에서도 해당 어노테이션을 사용할 수 있습니다. 스프링에서는 @Autowired를 통해 엔터티 매니저를 주입받을 수도 있습니다.
영속성 컨텍스트 관리:
엔터티 매니저는 영속성 컨텍스트를 관리하는 역할을 합니다. 영속성 컨텍스트는 엔터티의 생명주기를 추적하고, 엔터티를 데이터베이스와 동기화하는데 사용됩니다.
트랜잭션 범위:
엔터티 매니저는 트랜잭션 범위 내에서 동작합니다. 트랜잭션이 시작되면 엔터티 매니저가 생성되고, 트랜잭션이 커밋되거나 롤백되면 엔터티 매니저가 종료됩니다.


## 이 주장은 JPA에서 연관 관계를 설정할 때 지연 로딩(LAZY)을 사용하는 것을 권장하는 내용으로 보입니다. 여기서 몇 가지 핵심적인 내용을 설명하겠습니다:
즉시로딩(EAGER)의 문제:
EAGER 로딩은 연관된 엔티티를 즉시 로드하므로, 해당 엔티티와 관련된 데이터가 필요하지 않은 상황에서도 로드됩니다.
이로 인해 예측이 어렵고, 필요하지 않은 데이터를 로드하여 성능 문제가 발생할 수 있습니다.
특히, JPQL을 사용할 때 N+1 문제가 발생할 수 있습니다. N+1 문제는 관계된 엔티티를 조회할 때 추가적으로 N번의 쿼리가 발생하는 문제를 의미합니다.
지연로딩(LAZY) 권장:
LAZY 로딩은 연관된 엔티티가 실제로 사용될 때까지 데이터를 로드하지 않고, 필요한 시점에 로딩합니다.
이는 성능 최적화 측면에서 유리하며, 필요한 데이터만 로드되므로 불필요한 데이터를 피할 수 있습니다.
@XToOne 관계의 기본로딩:
@OneToOne 및 @ManyToOne 관계는 JPA에서 기본적으로 EAGER 로딩이 적용됩니다.
이러한 경우, 실무에서는 직접 LAZY 로딩으로 설정해주어야 합니다.

## 도메인 주도 설계

## JPA 가장 큰 장점 -> 쿼리를 따로 안 날려도 되기 떄문에 객체 지향 설계가 가능하다.
객체-관계 매핑 (Object-Relational Mapping, ORM): JPA는 객체와 데이터베이스 간의 매핑을 위한 강력한 기능을 제공합니다. 
엔터티 클래스를 정의하고 JPA 애노테이션을 사용하여 객체와 테이블 간의 매핑을 설정할 수 있습니다. 
이로써 객체 지향적인 디자인을 그대로 유지하면서 데이터베이스와 연동할 수 있습니다.
객체导向查询 (JPQL): JPA는 데이터베이스에 직접 SQL 쿼리를 작성하는 대신 JPQL을 사용하여 객체를 대상으로 쿼리를 작성할 수 있는 기능을 제공합니다. 
JPQL은 엔터티와 필드를 기반으로 쿼리를 작성하므로 SQL과는 다르게 테이블이 아닌 엔터티와 필드를 대상으로 쿼리할 수 있습니다.
TypedQuery<Product> query = entityManager.createQuery("SELECT p FROM Product p WHERE p.name = :productName", Product.class);
query.setParameter("productName", "Laptop");
List<Product> laptops = query.getResultList();
지연 로딩 (Lazy Loading): JPA는 연관 관계에서 지연 로딩을 지원합니다. 이는 연관된 엔터티를 실제로 사용할 때까지 데이터베이스에서 로딩을 지연시킬 수 있습니다. 
이는 성능 최적화와 객체 그래프의 효율적인 관리를 가능하게 합니다.

## CASCADE
여기서 cascade = CascadeType.ALL은 주문 엔터티의 모든 상태 변화가 연관된 Delivery와 OrderItem 엔터티에게도 전파되도록 설정한 것입니다. 
주문을 저장할 때, 수정할 때, 삭제할 때 등의 작업이 발생하면 해당 작업이 Delivery와 OrderItem에도 적용됩니다.

따라서, 주문을 저장하는 시점에서 orderRepository.save(order)를 호출하면 다음과 같은 일이 발생합니다:
(트랜잭션이 커밋되는 시점에 em.flush되면서 데이터베이스에 반영된다
주문(Order)이 저장됩니다.
주문과 연관된 Delivery도 저장됩니다. (cascade = CascadeType.ALL 때문에)
주문과 연관된 OrderItem도 저장됩니다. (cascade = CascadeType.ALL 때문에)
이런식으로 cascade 설정을 통해 부모 엔터티의 상태 변화가 자식 엔터티에게 전파되므로, 특별한 처리 없이도 주문을 저장하면 연관된 Delivery와 OrderItem도 함께 저장됩니다.
Delivery와 Order은 서로 다른 객체이지만 현재 일대일로 매핑되어있고, cascade설장까지 되어있다. 
원래는 각각 리포지토리에서 em이 persist등을 해주어야 하지만 현재는 Order 클래스에에 cascade설정이 되어 있으므로 order만 persist해주면 
그 상태가 매핑되어 있는 delivery에도 전파된다. 부모 엔티티가 딱 하나인 경우에만 cascade를 쓰는 게 좋다(라이프 사이클이 같을 때). 여러곳에서 참조할 경우 유지보수가 어려워진다
매핑이 복잡하게 얽혀있으면 cascade를 쓰는 것 보다. 별도의  리포지토리를 생성해서 persist하는 게 낫다.