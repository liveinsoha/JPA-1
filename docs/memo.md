## @DiscriminatorColumn은 Java에서 객체 지향 매핑(ORM)을 수행하는데 사용되는 어노테이션 중 하나로,
Hibernate와 같은 ORM 프레임워크에서 엔티티 클래스의 계층 구조를 매핑하는 데 사용됩니다. 특히, 상속 관계 매핑에서 사용됩니다.
해당 어노테이션은 하위 클래스들을 식별하기 위한 열을 데이터베이스 테이블에 추가하는 데 사용됩니다.
일반적으로 하위 클래스들은 부모 클래스를 상속받아 구현되며, 데이터베이스 테이블에 저장될 때 각각의 행은 자체의
특정 타입을 나타내는데, 이를 구분하기 위해 @DiscriminatorColumn이 사용됩니다.
@DiscriminatorColumn 어노테이션에는 name 속성이 있습니다. 여기서 "dtype"는 데이터베이스 테이블에
추가될 열의 이름을 지정합니다. "dtype"는 "Discriminator Type"의 약어로, 하위 클래스들을 식별하는 데 사용되는 열입니다.

## 엔터티 매니징 (Entity Management):
EntityManager는 JPA에서 엔터티의 생명주기를 관리하고 영속성 컨텍스트를 통해 엔터티 객체의 상태를 추적합니다. 영속성 컨텍스트는 엔터티와 데이터베이스 간의 매핑을 담당하며, 엔터티의 영속성 상태를 관리합니다.
영속성(Persistence): 영속성이란 엔터티 객체가 데이터베이스와 연결되어 있는 상태를 말합니다. 즉, 엔터티의 상태가 영속성 컨텍스트에 의해 추적되고 데이터베이스에 저장될 수 있게 되는 것을 의미합니다.
트랜잭션 범위 내에서의 관리: EntityManager를 사용하여 엔터티를 조회, 저장, 수정, 삭제할 때는 트랜잭션 범위 내에서 이루어져야 합니다. 이는 변경된 엔터티들이 데이터베이스에 일괄적으로 반영되거나 롤백될 수 있도록 보장합니다.
트랜잭션 관리:
EntityManager는 트랜잭션을 시작하고 커밋 또는 롤백하는 데 사용됩니다. 트랜잭션은 일련의 연산을 논리적으로 묶어서 원자적으로 실행하는 데 사용됩니다. 엔터티 매니징은 트랜잭션 내에서 이루어져야 하며, 트랜잭션을 통해 엔터티의 영속성 상태가 일관되게 유지됩니다.
트랜잭션의 커밋과 롤백: EntityManager를 통해 엔터티를 조작한 후, 트랜잭션을 커밋하면 변경사항이 데이터베이스에 반영되고, 롤백하면 변경사항이 취소되어 이전 상태로 돌아갑니다.
트랜잭션의 범위: 엔터티 매니징은 트랜잭션 내에서만 이루어져야 하며, 트랜잭션 범위 밖에서는 영속성 컨텍스트가 적용되지 않습니다.

## 도메인 개발 -> 서비스, 리포지토리 계층 개발 -> 테스트 작성하고 검증 -> 마지막에 웹 계층 적용


## em.persist(member)를 호출하는 시점에서 member 엔터티의 @Id 필드가 자동으로 생성되어 지정되어야 합니다.
JPA에서 엔터티가 데이터베이스에 저장될 때, 해당 엔터티의 @Id 필드가 자동으로 생성되는 방법은 크게 두 가지입니다:
자동 생성 전략 (Auto Generation Strategy):
일반적으로 @Id 필드에 대한 자동 생성 전략을 설정합니다. 대표적으로 사용되는 전략은 GenerationType.IDENTITY, GenerationType.SEQUENCE, GenerationType.TABLE, GenerationType.AUTO 등이 있습니다.
예를 들어, GenerationType.IDENTITY를 사용하면 데이터베이스의 자동 증가(Auto Increment) 기능을 활용하여 @Id 필드의 값을 자동으로 생성합니다.
기본 키 생성 전략 (Primary Key Generation Strategy):
데이터베이스에서 자동 생성된 키 값을 가져오는 방법으로, 데이터베이스에 따라 시퀀스, 테이블 등을 활용할 수 있습니다.

## 생성자 주입의 장점
불변성(Immutability) 및 불변 객체:
생성자 주입을 사용하면 한 번 생성된 객체는 불변하게 유지될 수 있습니다. 의존성이 객체 생성 시 주입되면, 
이후에 해당 객체는 내부 상태를 변경하지 않아도 됩니다. 이는 코드를 더 안정적으로 만들어주고, 예측 가능한 객체 상태를 제공합니다.
의존성 주입을 강제화(Forced Dependency):
생성자 주입은 객체 생성 시에 필요한 모든 의존성을 주입받아야 하기 때문에, 필수적인 의존성이 빠지지 않도록 강제할 수 있습니다. 
이는 객체가 필요한 의존성을 가지고 있는지를 보다 명확하게 확인할 수 있게 해줍니다.
의존성 추적과 가시성(Visibility):
생성자 주입을 사용하면 객체의 의존성이 외부에서 주입되므로, 코드를 읽는 사람이나 다른 개발자가 클래스의 의존성을 추적하기가 더 쉬워집니다. 
코드의 가시성이 높아져서 클래스가 어떤 의존성을 필요로 하는지 명확하게 보이게 됩니다.
테스트 용이성(Testability):
생성자 주입을 사용하면 의존성을 쉽게 목(mock) 객체로 대체할 수 있습니다. 테스트 코드에서 특정 의존성을 주입함으로써 특정 동작을 시뮬레이션하거나 테스트할 수 있습니다.
의존성의 변경 용이성:
생성자 주입을 사용하면 의존성이 변경될 경우에도 클래스 내부 변경이 최소화됩니다. 생성자의 파라미터만 수정하면 되기 때문에, 의존성의 변경에 따른 영향을 최소화할 수 있습니다.
Spring Framework와의 호환성:
Spring Framework에서는 생성자 주입을 선호하고 지원합니다. Spring의 @Autowired 어노테이션을 사용할 때 생성자 주입을 하면, 코드의 가독성이 향상되며 Spring 컨테이너의 의존성 주입 기능을 최대한 활용할 수 있습니다.

## @PersistenceContext 어노테이션은 JPA(Java Persistence API)에서 사용되며, 영속성 컨텍스트를 주입받기 위해 사용됩니다. 
이 어노테이션을 사용하면 엔터티 매니저(EntityManager)를 주입받아 JPA를 사용하는 클래스에서 데이터베이스와의 상호작용을 할 수 있습니다.
여기서 몇 가지 주요한 포인트를 설명하겠습니다:

엔터티 매니저 주입:
@PersistenceContext 어노테이션을 필드, 메서드, 또는 생성자에 적용하여 엔터티 매니저를 주입받을 수 있습니다.
주입된 엔터티 매니저를 사용하여 영속성 컨텍스트에서 엔터티의 조회, 저장, 수정, 삭제 등의 작업을 수행할 수 있습니다.
스프링에서의 활용:
@PersistenceContext는 주로 Java EE 환경에서 사용되었으나, 스프링에서도 해당 어노테이션을 사용할 수 있습니다. 스프링에서는 @Autowired를 통해 엔터티 매니저를 주입받을 수도 있습니다.
영속성 컨텍스트 관리:
엔터티 매니저는 영속성 컨텍스트를 관리하는 역할을 합니다. 영속성 컨텍스트는 엔터티의 생명주기를 추적하고, 엔터티를 데이터베이스와 동기화하는데 사용됩니다.
트랜잭션 범위:
엔터티 매니저는 트랜잭션 범위 내에서 동작합니다. 트랜잭션이 시작되면 엔터티 매니저가 생성되고, 트랜잭션이 커밋되거나 롤백되면 엔터티 매니저가 종료됩니다.


## 이 주장은 JPA에서 연관 관계를 설정할 때 지연 로딩(LAZY)을 사용하는 것을 권장하는 내용으로 보입니다. 여기서 몇 가지 핵심적인 내용을 설명하겠습니다:
즉시로딩(EAGER)의 문제:
EAGER 로딩은 연관된 엔티티를 즉시 로드하므로, 해당 엔티티와 관련된 데이터가 필요하지 않은 상황에서도 로드됩니다.
이로 인해 예측이 어렵고, 필요하지 않은 데이터를 로드하여 성능 문제가 발생할 수 있습니다.
특히, JPQL을 사용할 때 N+1 문제가 발생할 수 있습니다. N+1 문제는 관계된 엔티티를 조회할 때 추가적으로 N번의 쿼리가 발생하는 문제를 의미합니다.
지연로딩(LAZY) 권장:
LAZY 로딩은 연관된 엔티티가 실제로 사용될 때까지 데이터를 로드하지 않고, 필요한 시점에 로딩합니다.
이는 성능 최적화 측면에서 유리하며, 필요한 데이터만 로드되므로 불필요한 데이터를 피할 수 있습니다.
@XToOne 관계의 기본로딩:
@OneToOne 및 @ManyToOne 관계는 JPA에서 기본적으로 EAGER 로딩이 적용됩니다.
이러한 경우, 실무에서는 직접 LAZY 로딩으로 설정해주어야 합니다.

## 도메인 주도 설계

## JPA 가장 큰 장점 -> 쿼리를 따로 안 날려도 되기 떄문에 객체 지향 설계가 가능하다.
객체-관계 매핑 (Object-Relational Mapping, ORM): JPA는 객체와 데이터베이스 간의 매핑을 위한 강력한 기능을 제공합니다. 
엔터티 클래스를 정의하고 JPA 애노테이션을 사용하여 객체와 테이블 간의 매핑을 설정할 수 있습니다. 
이로써 객체 지향적인 디자인을 그대로 유지하면서 데이터베이스와 연동할 수 있습니다.
객체导向查询 (JPQL): JPA는 데이터베이스에 직접 SQL 쿼리를 작성하는 대신 JPQL을 사용하여 객체를 대상으로 쿼리를 작성할 수 있는 기능을 제공합니다. 
JPQL은 엔터티와 필드를 기반으로 쿼리를 작성하므로 SQL과는 다르게 테이블이 아닌 엔터티와 필드를 대상으로 쿼리할 수 있습니다.
TypedQuery<Product> query = entityManager.createQuery("SELECT p FROM Product p WHERE p.name = :productName", Product.class);
query.setParameter("productName", "Laptop");
List<Product> laptops = query.getResultList();
지연 로딩 (Lazy Loading): JPA는 연관 관계에서 지연 로딩을 지원합니다. 이는 연관된 엔터티를 실제로 사용할 때까지 데이터베이스에서 로딩을 지연시킬 수 있습니다. 
이는 성능 최적화와 객체 그래프의 효율적인 관리를 가능하게 합니다.

## CASCADE
여기서 cascade = CascadeType.ALL은 주문 엔터티의 모든 상태 변화가 연관된 Delivery와 OrderItem 엔터티에게도 전파되도록 설정한 것입니다. 
주문을 저장할 때, 수정할 때, 삭제할 때 등의 작업이 발생하면 해당 작업이 Delivery와 OrderItem에도 적용됩니다.

따라서, 주문을 저장하는 시점에서 orderRepository.save(order)를 호출하면 다음과 같은 일이 발생합니다:
(트랜잭션이 커밋되는 시점에 em.flush되면서 데이터베이스에 반영된다
주문(Order)이 저장됩니다.
주문과 연관된 Delivery도 저장됩니다. (cascade = CascadeType.ALL 때문에)
주문과 연관된 OrderItem도 저장됩니다. (cascade = CascadeType.ALL 때문에)
이런식으로 cascade 설정을 통해 부모 엔터티의 상태 변화가 자식 엔터티에게 전파되므로, 특별한 처리 없이도 주문을 저장하면 연관된 Delivery와 OrderItem도 함께 저장됩니다.
Delivery와 Order은 서로 다른 객체이지만 현재 일대일로 매핑되어있고, cascade설장까지 되어있다. 
원래는 각각 리포지토리에서 em이 persist등을 해주어야 하지만 현재는 Order 클래스에에 cascade설정이 되어 있으므로 order만 persist해주면 
그 상태가 매핑되어 있는 delivery에도 전파된다. 부모 엔티티가 딱 하나인 경우에만 cascade를 쓰는 게 좋다(라이프 사이클이 같을 때). 여러곳에서 참조할 경우 유지보수가 어려워진다
매핑이 복잡하게 얽혀있으면 cascade를 쓰는 것 보다. 별도의  리포지토리를 생성해서 persist하는 게 낫다.

## th:replace는 Thymeleaf 템플릿 엔진에서 사용되는 속성으로, 특정 속성값에 해당하는 템플릿(fragment)을 현재 위치에 치환(대체)하는 역할을 합니다. 
이를 통해 웹 페이지의 일부를 모듈화하고 재사용성을 높일 수 있습니다.
head th:replace="fragments/header :: header"에서 각 부분의 역할을 살펴보겠습니다:
head: 이는 현재 위치에 특정 템플릿을 대체할 때 어떤 태그에 적용할지를 나타냅니다. 여기서는 <head> 태그에 대체됩니다.
th:replace: Thymeleaf의 속성으로, 지정된 위치에 특정 템플릿을 대체하도록 지시하는 역할을 합니다.
fragments/header: 대체할 템플릿의 경로를 지정합니다. fragments는 템플릿이 위치한 디렉토리이며, header는 대체할 템플릿의 이름입니다.
:: header: fragments/header에서 대체할 템플릿의 일부분을 지정하는 것으로, 여기서는 header 템플릿 전체를 대체하도록 합니다.
이러한 설정은 보통 웹 페이지의 공통된 부분(예: 헤더, 푸터)을 따로 분리하여 재사용하고자 할 때 사용됩니다. 
따라서 fragments/header 템플릿에는 <head> 태그 내에서 필요한 CSS, JavaScript 파일 링크, 메타 정보 등이 정의되어 있을 것이고, 
이를 다른 페이지에서 head에 적용함으로써 중복된 코드를 피할 수 있습니다.

## 폼(Form)-서브밋(submit) 방식은 웹 페이지에서 사용자가 폼에 입력한 데이터를 서버로 전송하는 방식을 의미합니다. 
사용자가 웹 페이지에서 어떤 동작을 수행하기 위해 정보를 입력하고 제출(submit)할 때 이 방식이 사용됩니다. 주로 HTML <form> 요소를 사용하여 구현됩니다.
폼-서브밋의 주요 특징은 다음과 같습니다:
HTML <form> 요소: 폼은 HTML <form> 요소로 정의되며, 사용자가 입력할 수 있는 여러 종류의 입력 필드(텍스트 상자, 체크 박스, 라디오 버튼 등)와 제출 버튼이 포함됩니다.
폼 데이터 전송: 사용자가 입력한 데이터는 폼 안의 입력 필드들에 의해 정의된 데이터로 구성됩니다. 이 데이터는 폼을 제출(submit)할 때 서버로 전송됩니다.
제출 버튼: 사용자는 폼 안에 있는 제출 버튼(일반적으로 "Submit" 또는 "확인" 버튼)을 클릭하여 폼을 서버로 제출합니다.
HTTP 요청 메서드: 제출된 폼은 HTTP 요청 메서드 중 하나인 GET 또는 POST를 사용하여 서버로 전송됩니다. 일반적으로, GET은 주로 검색 쿼리와 같이 데이터를 URL에 첨부할 때 사용되며, POST는 주로 데이터를 요청 본문에 담아 전송할 때 사용됩니다.
예시:
````
html
<form action="/submit" method="post">
    <label for="username">사용자 이름:</label>
    <input type="text" id="username" name="username">

    <label for="password">비밀번호:</label>
    <input type="password" id="password" name="password">

    <button type="submit">제출</button>
</form>
````
위의 예시에서는 사용자가 사용자 이름과 비밀번호를 입력하고 "제출" 버튼을 클릭하면 /submit 경로로 POST 요청이 서버에 전송됩니다. 
서버는 이러한 데이터를 받아 처리하고, 클라이언트에 대한 응답을 생성할 수 있습니다.

## <td> (Table Data):
`<td>`는 HTML에서 표(table)의 각 행(row)에 있는 데이터 셀을 정의하는 태그입니다.
Thymeleaf의 th:text 속성을 사용하여 해당 셀에 동적으로 데이터를 바인딩합니다. 이는 서버 측에서 전달된 데이터를 클라이언트 측 HTML에 표시하는 데 사용됩니다.
html
Copy code

<!--    <td th:text="${item.id}"></td>
위의 예시에서 item.id는 서버에서 전달받은 각 아이템의 ID를 나타내며, 이를 해당 행의 첫 번째 셀에 표시합니다.

## <a> (Anchor):
<a>는 HTML에서 하이퍼링크(링크)를 생성하는 태그입니다.
Thymeleaf의 th:href 속성을 사용하여 링크의 주소를 동적으로 생성합니다. 주로 서버로부터 받은 데이터를 기반으로 동적인 주소를 생성할 때 활용됩니다.
html
Copy code
<a href="#" th:href="@{/items/{id}/edit (id=${item.id})}" class="btn btn-primary" role="button">수정</a>
위의 예시에서 @{/items/{id}/edit (id=${item.id})}는 링크의 주소를 동적으로 생성합니다. ${item.id}는 각 아이템의 ID를 나타내며, 
예를 들어, /items/1/edit, /items/2/edit, ...와 같은 형태로 생성됩니다. 이렇게 생성된 주소는 클라이언트가 클릭할 때 해당 링크로 이동하게 됩니다.

종합적으로, <td>는 표의 데이터 셀을 나타내며, th:text 속성을 통해 동적으로 데이터를 표시합니다. <a>는 하이퍼링크를 생성하며, 
th:href 속성을 통해 동적으로 링크의 주소를 생성합니다. 이러한 기능들은 Thymeleaf를 통해 서버에서 전달된 데이터를 동적으로 HTML에 표시하고, 
클라이언트와 서버 간의 상호작용을 가능케 합니다.

## action과 method는 HTML <form> 요소에서 사용되는 속성으로, 폼이 서버로 제출될 때의 동작을 정의합니다.

### action 속성:
action 속성은 폼 데이터가 제출될 때 데이터가 전송되는 서버의 URL을 나타냅니다.
주로 서버 측 컨트롤러나 서블릿에 해당하는 엔드포인트의 경로를 지정합니다.
html
Copy code

<form action="/submit" method="post">
    <!-- 폼 내용 -->
</form>


위의 예시에서는 폼이 /submit 경로로 데이터를 전송합니다. 실제로는 서버에서 이 경로에 해당하는 로직을 수행하는 컨트롤러나 서블릿이 있어야 합니다.

### method 속성:
method 속성은 폼 데이터를 서버로 전송할 때 사용되는 HTTP 요청 메서드를 나타냅니다.
가장 일반적으로 사용되는 메서드는 GET과 POST입니다. GET은 데이터를 URL에 첨부하여 전송하고, POST는 요청 본문에 데이터를 담아 전송합니다.
html
Copy code
``````
<form action="/submit" method="post">
    <!-- 폼 내용 -->
</form>
``````
위의 예시에서는 method="post"로 설정되어 있으므로, 폼 데이터는 POST 메서드를 사용하여 서버로 전송됩니다.

예시:
````
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Example</title>
</head>
<body>
    <form action="/submit" method="post">
        <label for="username">사용자 이름:</label>
        <input type="text" id="username" name="username">

        <label for="password">비밀번호:</label>
        <input type="password" id="password" name="password">

        <button type="submit">제출</button>
    </form>
</body>
</html>
````

위의 예시에서는 폼이 /submit 경로로 POST 메서드를 사용하여 데이터를 전송하도록 설정되어 있습니다. 
이 폼을 사용자가 제출하면, 입력된 사용자 이름과 비밀번호는 서버로 전송되어 /submit에 해당하는 서버 로직을 실행하게 됩니다.

## HTML <form> 요소에 action 속성이 없는 경우, 폼 데이터는 현재 URL로 전송됩니다. 이는 폼이 있는 현재 페이지의 URL로 데이터를 전송한다는 의미입니다. 

예를 들어, 현재 페이지 URL이 "http://example.com/form"인 경우, 폼이 제출되면 데이터는 "http://example.com/form"으로 전송됩니다.
아래는 action 속성이 없는 <form> 요소의 예시입니다:
html
```
<form th:object="${form}" method="post">
    <!-- 폼 내용 -->
</form>
```
이 경우, 폼 데이터는 현재 페이지 URL로 전송됩니다. 이러한 방식은 단일 페이지 애플리케이션(SPA)이나 데이터를 현재 페이지에서 처리하는 경우에 주로 사용됩니다.
참고: action 속성이 없는 폼을 사용하는 것은 특별한 상황에 해당하며, 
대부분의 경우에는 명시적으로 action 속성을 설정하여 데이터를 전송할 엔드포인트를 지정하는 것이 권장됩니다.